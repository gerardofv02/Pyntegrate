from ._genomic_signal import *
from .persistence import *
from .array_helpers import *
import os
import gffutils
import pybedtools
from pybedtools.featurefuncs import TSS
from gffutils.helpers import asinterval
import multiprocessing
import numpy as np
import sys
from matplotlib import pyplot as plt

def tss_generator(db):
    """
    Generator function to yield TSS of each annotated transcript
    """
    for transcript in db.features_of_type('transcript'):
        yield TSS(asinterval(transcript), upstream=1, downstream=0)

def generate_arrays_features_from_tsses_from_db(dbPath, ipSignalPath, extensionIp,inputSignalPath,extensionInput, genome):

    """
    Function to process ChIP-seq data, specifically to analyze the protein enrichment signal in certain genomic regions, such as transcription start sites (TSS)

    Params:
        - dbPath: String: The path where database of CHIP-seq data is stored (It must be a db generated by the CHIP-seq data with pybedtools library)
        - ipSignalPath: String: The path where IP signal data is stored
        - extensionIp: String: Type of the file of the IP signal data file. Example:('bigwig','bam','bed',...)
        - inputSignalPath: String: The path where INPUT signal data is stored
        - extensionInput: String: Type of the file of the INPUT signal data file example:('bigwig','bam','bed',...)
        - genome: String: The genome of the CHIP-seq data we want to analyze. Example: ('hg19','hg38',...)
    """
    
    ##Primer paso 
    db = gffutils.FeatureDB(dbPath) #Primer paso
    tsses = pybedtools.BedTool(tss_generator(db)).saveas('tsses.gtf')

    remove_duplicates("tsses.gtf")
    tsses = pybedtools.BedTool("tsses.gtf")
    tsses_1kb = tsses.slop(b=1000, genome=genome, output='tsses-1kb.gtf')
    


    ##Segundo paso
    ip_signal = genomic_signal(ipSignalPath,extensionIp)
    input_signal = genomic_signal(inputSignalPath,extensionInput)
    
    
    

    print(ip_signal,input_signal)
    processes = multiprocessing.cpu_count()
    if not os.path.exists('example.npz'):

        ##Tercer paso

        # The signal is the IP ChIP-seq BAM file.
        ip_array = ip_signal.array(

            # Look at signal over these windows
            tsses_1kb,

            # Bin signal into this many bins per window
            bins=100,

            # Use multiple CPUs. Dramatically speeds up run time.
            processes=processes)

        # print(ip_array[0][:10])
        # Do the same thing for input.

        ##Cuartopaso
        input_array = input_signal.array(
            tsses_1kb,
            bins=100,
            processes=processes)

        # print(input_array[:10])



        # Normalize to library size. The values in the array
        # will be in units of "reads per million mapped reads"
        ##SExto paso

        ip_array /= ip_signal.mapped_read_count() / 1e6
        input_array /= input_signal.mapped_read_count() / 1e6


        print("Ip_array: " , ip_array)
        print("Input_array: " , input_array)

        ##SExto paso
        # Cache to disk. The data will be saved as "example.npz" and "example.features".
        save_features_and_arrays(
            features=tsses,
            arrays={'ip': ip_array, 'input': input_array},
            prefix='example',
            link_features=True,
            overwrite=True)

    features, arrays = load_features_and_arrays(prefix='example')
    return features ,arrays ,tsses, tsses_1kb



def calculate_peaks(arrays_ip, arrays_input):

    """
    Function to calculate the peaks between the IP signal and INPUT signal.
    Params:
        - arrays_ip: Array: The array of the IP signal data
        - arrays_input: Array: The array of the INPUT signal data
    """

    if(len(arrays_ip) != len(arrays_input)):
        sys.stderr.write("Length of ip is different from input array")
    peaks = arrays_ip - arrays_input
    return peaks


def distance_from_tss_chipSeq(arrays_ip, arrays_input):

    """
    Function to show in a graphic the distance of IP signal data and INPUT signal data from the TSS.
    Params:
        - arrays_ip: Array: The array of the IP signal data
        - arrays_input: Array: The array of the INPUT signal data
    """

    x = np.linspace(-1000, 1000, 100)


    # Create a figure and axes
    fig = plt.figure()
    ax = fig.add_subplot(111)


    # Plot the IP:
    ax.plot(
        # use the x-axis values we created
        x,

        # axis=0 takes the column-wise mean, so with
        # 100 columns we'll have 100 means to plot
        arrays_ip.mean(axis=0),

        # Make it red
        color='r',

        # Label to show up in legend
        label='IP')


    # Do the same thing with the input
    ax.plot(
        x,
        arrays_input.mean(axis=0),
        color='k',
        label='input')


    # Add a vertical line at the TSS, at position 0
    ax.axvline(0, linestyle=':', color='k')


    # Add labels and legend
    ax.set_xlabel('Distance from TSS (bp)')
    ax.set_ylabel('Average read coverage (per million mapped reads)')
    ax.legend(loc='best')
    return fig
